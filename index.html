<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Network Chat</title>
    <!-- Tailwind and Flowbite for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.2.0/flowbite.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.2.0/flowbite.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --primary-color: #5D5CDE;
        }
        
        .chat-container {
            height: calc(100vh - 180px);
            max-height: 600px;
        }
        
        .message {
            animation: fadeIn 0.3s ease-in-out;
            word-break: break-word;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .timestamp {
            font-size: 0.7rem;
            margin-left: 5px;
            opacity: 0.6;
        }
        
        .user-indicator {
            height: 8px;
            width: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }
        
        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #181818;
                color: #f0f0f0;
            }
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 min-h-screen">
    <div class="container mx-auto p-4 max-w-3xl">
        <!-- Username selection screen -->
        <div id="username-screen" class="flex flex-col items-center justify-center min-h-[80vh]">
            <div class="w-full max-w-md p-6 bg-white rounded-lg shadow-md dark:bg-gray-800">
                <h1 class="text-2xl font-bold text-center mb-6 text-gray-800 dark:text-white">Join the Chat</h1>
                <div class="mb-4">
                    <label for="username" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">Choose a username</label>
                    <input type="text" id="username" class="bg-gray-50 border border-gray-300 text-gray-900 text-base rounded-lg focus:ring-primary focus:border-primary block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white" 
                           placeholder="Enter your username" maxlength="20" required>
                    <p id="username-error" class="mt-2 text-sm text-red-600 dark:text-red-500 hidden">Please enter a valid username (3-20 characters).</p>
                </div>
                <div class="mb-4">
                    <label for="room" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">Room ID</label>
                    <input type="text" id="room" class="bg-gray-50 border border-gray-300 text-gray-900 text-base rounded-lg focus:ring-primary focus:border-primary block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white" 
                           placeholder="Enter a room ID to join or create" maxlength="20" required>
                    <p id="room-error" class="mt-2 text-sm text-red-600 dark:text-red-500 hidden">Please enter a valid room ID (3-20 characters, alphanumeric only).</p>
                </div>
                <button id="join-btn" class="w-full text-white bg-[var(--primary-color)] hover:bg-[#4b4ab2] focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center">
                    Join Chat
                </button>
                <div id="connection-status" class="mt-4 text-center text-sm text-gray-500 dark:text-gray-400"></div>
            </div>
        </div>

        <!-- Chat room screen (initially hidden) -->
        <div id="chat-screen" class="hidden">
            <div class="flex flex-col w-full">
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center space-x-2">
                        <h1 class="text-xl font-semibold text-gray-800 dark:text-white">Chat</h1>
                        <span class="py-0.5 px-2 bg-[var(--primary-color)] text-white text-xs rounded-full" id="room-badge"></span>
                    </div>
                    <div class="flex items-center">
                        <span class="text-sm text-gray-600 dark:text-gray-300 mr-2">Logged in as:</span>
                        <span id="current-user" class="font-semibold text-[var(--primary-color)]"></span>
                        <button id="change-username" class="ml-3 text-xs text-gray-600 dark:text-gray-400 hover:text-[var(--primary-color)] dark:hover:text-[var(--primary-color)]">
                            Change
                        </button>
                    </div>
                </div>
                
                <div class="flex items-center space-x-2 mb-2">
                    <span class="text-sm text-gray-600 dark:text-gray-300">Online:</span>
                    <div id="online-users" class="flex flex-wrap gap-1"></div>
                </div>
                
                <div id="messages-container" class="bg-gray-50 dark:bg-gray-800 rounded-lg p-4 overflow-y-auto chat-container mb-4">
                    <div class="flex justify-center p-4">
                        <p class="text-gray-500 dark:text-gray-400 text-sm">Welcome to the chat! Messages appear here.</p>
                    </div>
                </div>
                
                <div class="flex">
                    <input type="text" id="message-input" class="bg-gray-50 border border-gray-300 text-gray-900 text-base rounded-lg rounded-r-none focus:ring-[var(--primary-color)] focus:border-[var(--primary-color)] block flex-1 p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white" 
                           placeholder="Type your message...">
                    <button id="send-btn" class="text-white bg-[var(--primary-color)] hover:bg-[#4b4ab2] focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg rounded-l-none text-sm px-5 py-2.5">
                        Send
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Loading indicator (initially hidden) -->
        <div id="loading-screen" class="flex flex-col items-center justify-center min-h-[80vh] hidden">
            <div role="status" class="mb-4">
                <svg aria-hidden="true" class="w-12 h-12 text-gray-200 animate-spin dark:text-gray-600 fill-[var(--primary-color)]" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"/>
                    <path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"/>
                </svg>
                <span class="sr-only">Loading...</span>
            </div>
            <p id="loading-text" class="text-gray-700 dark:text-gray-300">Connecting to chat server...</p>
            <p id="connection-error" class="mt-3 text-red-500 dark:text-red-400 hidden">Connection failed. Please try again or check your connectivity.</p>
            <button id="retry-btn" class="mt-4 bg-[var(--primary-color)] text-white py-2 px-4 rounded hidden">Retry Connection</button>
        </div>
    </div>

    <script>
        // DOM elements
        const usernameScreen = document.getElementById('username-screen');
        const chatScreen = document.getElementById('chat-screen');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingText = document.getElementById('loading-text');
        const connectionError = document.getElementById('connection-error');
        const retryBtn = document.getElementById('retry-btn');
        const connectionStatus = document.getElementById('connection-status');
        const usernameInput = document.getElementById('username');
        const roomInput = document.getElementById('room');
        const usernameError = document.getElementById('username-error');
        const roomError = document.getElementById('room-error');
        const joinBtn = document.getElementById('join-btn');
        const currentUserSpan = document.getElementById('current-user');
        const roomBadge = document.getElementById('room-badge');
        const changeUsernameBtn = document.getElementById('change-username');
        const messagesContainer = document.getElementById('messages-container');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const onlineUsers = document.getElementById('online-users');
        
        // Chat state
        const chatState = {
            username: '',
            userId: null,
            isLoggedIn: false,
            messages: [],
            users: {},
            peer: null,
            connections: [],
            hostConnection: null,
            isHost: false,
            connectedToHost: false,
            colors: {},
            nextColor: 0,
            roomId: '',
            reconnectAttempts: 0,
            maxReconnectAttempts: 3,
            // Available colors for user indicators
            colorPalette: [
                '#FF5733', '#33FF57', '#3357FF', '#F033FF', '#FF33A8', 
                '#33FFF0', '#FFF033', '#FF8333', '#33FF83', '#8333FF'
            ],
            // Ice server configuration for PeerJS
            iceServers: [
                { url: 'stun:stun.l.google.com:19302' },
                { url: 'stun:stun1.l.google.com:19302' },
                { url: 'stun:stun2.l.google.com:19302' },
                { url: 'stun:stun3.l.google.com:19302' },
                { url: 'stun:stun4.l.google.com:19302' }
            ]
        };
        
        // Generate a random ID to use for this user
        function generateUserId() {
            return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        }
        
        // Create a valid peer ID by combining room and role
        function createPeerId(room, role, userId = null) {
            // Make room name safe for use in IDs
            const safeRoom = room.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
            if (role === 'host') {
                return `${safeRoom}-host`;
            } else {
                return `${safeRoom}-${userId}`;
            }
        }
        
        // Initialize PeerJS connection
        function initPeer() {
            // Show loading screen
            usernameScreen.classList.add('hidden');
            loadingScreen.classList.remove('hidden');
            connectionError.classList.add('hidden');
            retryBtn.classList.add('hidden');
            
            // Create a unique ID for this user
            chatState.userId = generateUserId();
            
            connectionStatus.textContent = 'Connecting to server...';
            loadingText.textContent = `Connecting to room "${chatState.roomId}"...`;
            
            // Get peer ID based on room and user ID
            const peerId = createPeerId(chatState.roomId, 'user', chatState.userId);
            
            // Initialize the PeerJS connection with ICE servers for NAT traversal
            chatState.peer = new Peer(peerId, {
                config: {
                    'iceServers': chatState.iceServers
                },
                debug: 2 // Set debug level (0-3)
            });
            
            // Handle connection to PeerJS server
            chatState.peer.on('open', (id) => {
                console.log('Connected to PeerJS server with ID:', id);
                connectionStatus.textContent = 'Connected! Joining chat...';
                loadingText.textContent = `Connected! Joining room "${chatState.roomId}"...`;
                chatState.reconnectAttempts = 0;
                
                // Try to connect to the "host" peer of this room
                findHost();
            });
            
            // Handle connection errors
            chatState.peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                
                if (err.type === 'peer-unavailable') {
                    // If no host is found, become the host
                    if (!chatState.isHost && !chatState.connectedToHost) {
                        becomeHost();
                    }
                } else if (err.type === 'network' || err.type === 'server-error') {
                    // Handle network errors
                    handleConnectionError();
                } else {
                    // Other errors
                    connectionStatus.textContent = 'Connection error. Please try again.';
                    loadingText.textContent = 'Connection error occurred.';
                    connectionError.textContent = `Error: ${err.type}`;
                    connectionError.classList.remove('hidden');
                    retryBtn.classList.remove('hidden');
                }
            });
            
            // Handle disconnection from the server
            chatState.peer.on('disconnected', () => {
                console.log('Disconnected from PeerJS server, attempting to reconnect...');
                
                if (chatState.reconnectAttempts < chatState.maxReconnectAttempts) {
                    chatState.reconnectAttempts++;
                    loadingText.textContent = `Connection lost. Reconnecting... (Attempt ${chatState.reconnectAttempts}/${chatState.maxReconnectAttempts})`;
                    
                    // Try to reconnect
                    setTimeout(() => {
                        chatState.peer.reconnect();
                    }, 1000);
                } else {
                    // Max reconnect attempts reached
                    handleConnectionError();
                }
            });
            
            // Handle incoming connections
            chatState.peer.on('connection', (conn) => {
                console.log('Incoming connection from:', conn.peer);
                handleNewConnection(conn);
            });
        }
        
        // Handle connection errors
        function handleConnectionError() {
            loadingText.textContent = 'Unable to connect to the chat server.';
            connectionError.textContent = 'Connection failed. Please check your internet connection and try again.';
            connectionError.classList.remove('hidden');
            retryBtn.classList.remove('hidden');
        }
        
        // Try to find a host to connect to
        function findHost() {
            try {
                // Try to connect to the host for this room
                const hostId = createPeerId(chatState.roomId, 'host');
                console.log('Trying to connect to host:', hostId);
                
                const hostConnection = chatState.peer.connect(hostId, {
                    reliable: true
                });
                
                hostConnection.on('open', () => {
                    console.log('Connected to host!');
                    chatState.hostConnection = hostConnection;
                    chatState.connectedToHost = true;
                    
                    // Now that we're connected, send our username to join the chat
                    hostConnection.send({
                        type: 'join',
                        username: chatState.username,
                        userId: chatState.userId,
                        roomId: chatState.roomId,
                        timestamp: new Date().toISOString()
                    });
                    
                    // Handle data from the host
                    hostConnection.on('data', handlePeerMessage);
                    
                    // Handle connection close
                    hostConnection.on('close', () => {
                        console.log('Host connection closed');
                        chatState.connectedToHost = false;
                        
                        if (chatState.isLoggedIn) {
                            // Add system message
                            addMessage({
                                sender: 'System',
                                content: 'Connection to host lost. Attempting to reconnect or become host...',
                                timestamp: new Date().toISOString(),
                                isSystem: true
                            });
                            
                            // Try to become the host
                            becomeHost();
                        }
                    });
                });
                
                hostConnection.on('error', (err) => {
                    console.error('Error connecting to host:', err);
                    // If we can't connect to a host, become the host
                    becomeHost();
                });
            } catch (err) {
                console.error('Error finding host:', err);
                becomeHost();
            }
        }
        
        // Become the host peer
        function becomeHost() {
            if (chatState.isHost || chatState.connectedToHost) return;
            
            console.log('Becoming host for room:', chatState.roomId);
            loadingText.textContent = `Creating room "${chatState.roomId}"...`;
            
            // Close the current peer connection
            if (chatState.peer) {
                chatState.peer.destroy();
            }
            
            // Create a new peer with the host ID for this room
            const hostId = createPeerId(chatState.roomId, 'host');
            chatState.peer = new Peer(hostId, {
                config: {
                    'iceServers': chatState.iceServers
                },
                debug: 2
            });
            
            chatState.peer.on('open', (id) => {
                console.log('Now hosting as:', id);
                chatState.isHost = true;
                
                // Show the chat UI now that we're connected
                loadingScreen.classList.add('hidden');
                chatScreen.classList.remove('hidden');
                
                // Update UI
                updateCurrentUser();
                roomBadge.textContent = chatState.roomId;
                
                // Add ourselves to the user list
                addUser(chatState.userId, chatState.username);
                
                // Add a system message
                addMessage({
                    sender: 'System',
                    content: `You have created a new chat room "${chatState.roomId}" as ${chatState.username}`,
                    timestamp: new Date().toISOString(),
                    isSystem: true
                });
            });
            
            // Handle incoming connections as the host
            chatState.peer.on('connection', (conn) => {
                console.log('Host received connection from:', conn.peer);
                handleNewConnection(conn);
            });
            
            // Handle host errors
            chatState.peer.on('error', (err) => {
                console.error('Host error:', err);
                
                // If we get an 'unavailable-id' error, someone else is already hosting
                if (err.type === 'unavailable-id') {
                    // Try to connect to that host instead
                    chatState.isHost = false;
                    initPeer();
                } else if (err.type === 'network' || err.type === 'server-error') {
                    // Handle network errors
                    if (chatState.isLoggedIn) {
                        // We were already logged in, so add a system message
                        addMessage({
                            sender: 'System',
                            content: 'Connection to server lost. Messages may not be sent until reconnected.',
                            timestamp: new Date().toISOString(),
                            isSystem: true
                        });
                    } else {
                        // We weren't logged in yet, so show the error
                        handleConnectionError();
                    }
                }
            });
            
            // Handle disconnection from the server
            chatState.peer.on('disconnected', () => {
                console.log('Host disconnected from PeerJS server, attempting to reconnect...');
                
                if (chatState.isLoggedIn) {
                    // We were already logged in, so add a system message
                    addMessage({
                        sender: 'System',
                        content: 'Connection to server lost. Attempting to reconnect...',
                        timestamp: new Date().toISOString(),
                        isSystem: true
                    });
                    
                    // Try to reconnect
                    if (chatState.reconnectAttempts < chatState.maxReconnectAttempts) {
                        chatState.reconnectAttempts++;
                        
                        setTimeout(() => {
                            chatState.peer.reconnect();
                        }, 1000);
                        
                        // Add another system message when reconnected
                        chatState.peer.once('open', () => {
                            addMessage({
                                sender: 'System',
                                content: 'Reconnected to server successfully.',
                                timestamp: new Date().toISOString(),
                                isSystem: true
                            });
                        });
                    }
                } else {
                    // We weren't logged in yet, so show the error
                    handleConnectionError();
                }
            });
        }
        
        // Handle a new peer connection
        function handleNewConnection(conn) {
            // Add the connection to our list
            chatState.connections.push(conn);
            
            // Handle data from this peer
            conn.on('open', () => {
                console.log('Connection open to:', conn.peer);
                
                // If we're the host and this is a new connection,
                // send them the current state of the chat
                if (chatState.isHost) {
                    console.log('Sending current state to new peer');
                    conn.send({
                        type: 'init',
                        users: chatState.users,
                        messages: chatState.messages,
                        colors: chatState.colors,
                        roomId: chatState.roomId,
                        timestamp: new Date().toISOString()
                    });
                }
            });
            
            // Handle messages from this peer
            conn.on('data', (data) => {
                handlePeerMessage(data, conn);
            });
            
            // Handle disconnection
            conn.on('close', () => {
                console.log('Connection closed to:', conn.peer);
                
                // Remove the connection from our list
                chatState.connections = chatState.connections.filter(c => c !== conn);
                
                // If we're the host, inform others about the disconnection
                if (chatState.isHost) {
                    // Extract userId from the peer connection
                    // For multi-room, we need to extract just the user part
                    const peerId = conn.peer;
                    // The peer ID is in format: roomid-userId
                    const parts = peerId.split('-');
                    // The userId is everything after the first dash
                    const userId = parts.slice(1).join('-');
                    
                    const username = chatState.users[userId];
                    
                    if (username) {
                        // Remove the user
                        delete chatState.users[userId];
                        
                        // Add a system message about the user leaving
                        const leaveMessage = {
                            type: 'leave',
                            userId: userId,
                            username: username,
                            roomId: chatState.roomId,
                            timestamp: new Date().toISOString()
                        };
                        
                        // Process the leave message ourselves
                        processLeaveMessage(leaveMessage);
                        
                        // Send to all other peers
                        broadcastToPeers(leaveMessage);
                        
                        // Update the UI
                        updateOnlineUsers();
                    }
                }
            });
            
            // Handle connection errors
            conn.on('error', (err) => {
                console.error('Connection error with peer:', conn.peer, err);
                
                // Remove this connection from our list
                chatState.connections = chatState.connections.filter(c => c !== conn);
            });
        }
        
        // Handle a message from a peer
        function handlePeerMessage(data, sourceConn = null) {
            console.log('Received peer message:', data);
            
            switch (data.type) {
                case 'chat':
                    // Add the message to our chat
                    addMessage({
                        sender: data.username,
                        content: data.content,
                        timestamp: data.timestamp,
                        userId: data.userId,
                        isSystem: false
                    });
                    
                    // If we're the host, broadcast this message to all other peers
                    if (chatState.isHost && sourceConn) {
                        broadcastToPeers(data, sourceConn);
                    }
                    break;
                    
                case 'join':
                    // A new user is joining
                    if (chatState.isHost) {
                        // Add the user to our list
                        addUser(data.userId, data.username);
                        
                        // Send a system message
                        const joinMessage = {
                            type: 'system',
                            content: `${data.username} has joined the chat`,
                            timestamp: data.timestamp,
                            isSystem: true
                        };
                        
                        // Add the message locally
                        addMessage({
                            sender: 'System',
                            content: joinMessage.content,
                            timestamp: joinMessage.timestamp,
                            isSystem: true
                        });
                        
                        // Broadcast to all peers
                        broadcastToPeers(joinMessage);
                        
                        // Also broadcast the updated user list
                        broadcastToPeers({
                            type: 'users',
                            users: chatState.users,
                            colors: chatState.colors,
                            timestamp: new Date().toISOString()
                        });
                    }
                    break;
                    
                case 'init':
                    // We're receiving the initial state of the chat
                    if (!chatState.isHost) {
                        // Set the users and messages
                        chatState.users = data.users;
                        chatState.colors = data.colors;
                        chatState.roomId = data.roomId;
                        
                        // Update room badge and user display
                        roomBadge.textContent = chatState.roomId;
                        updateCurrentUser();
                        
                        // Add all messages
                        data.messages.forEach(msg => {
                            addMessage(msg, false); // Don't re-broadcast these messages
                        });
                        
                        // Update the UI
                        updateOnlineUsers();
                        
                        // Show the chat UI
                        loadingScreen.classList.add('hidden');
                        chatScreen.classList.remove('hidden');
                        
                        // Send a join message to others via the host
                        chatState.hostConnection.send({
                            type: 'join',
                            username: chatState.username,
                            userId: chatState.userId,
                            roomId: chatState.roomId,
                            timestamp: new Date().toISOString()
                        });
                    }
                    break;
                    
                case 'system':
                    // System message
                    addMessage({
                        sender: 'System',
                        content: data.content,
                        timestamp: data.timestamp,
                        isSystem: true
                    });
                    
                    // If we're the host, broadcast this message
                    if (chatState.isHost && sourceConn) {
                        broadcastToPeers(data, sourceConn);
                    }
                    break;
                    
                case 'leave':
                    // A user is leaving
                    processLeaveMessage(data);
                    
                    // If we're the host, broadcast this message
                    if (chatState.isHost && sourceConn) {
                        broadcastToPeers(data, sourceConn);
                    }
                    break;
                    
                case 'users':
                    // Update to the user list
                    if (!chatState.isHost) {
                        chatState.users = data.users;
                        chatState.colors = data.colors;
                        updateOnlineUsers();
                    }
                    break;
            }
        }
        
        // Process a leave message
        function processLeaveMessage(data) {
            // Remove the user from our list
            if (chatState.users[data.userId]) {
                delete chatState.users[data.userId];
                
                // Add a system message
                addMessage({
                    sender: 'System',
                    content: `${data.username} has left the chat`,
                    timestamp: data.timestamp,
                    isSystem: true
                });
                
                // Update the UI
                updateOnlineUsers();
            }
        }
        
        // Broadcast a message to all connected peers
        function broadcastToPeers(data, exceptConn = null) {
            if (!chatState.isHost) return;
            
            chatState.connections.forEach(conn => {
                if (conn !== exceptConn && conn.open) {
                    try {
                        conn.send(data);
                    } catch (err) {
                        console.error('Error sending data to peer:', conn.peer, err);
                    }
                }
            });
        }
        
        // Add a user to the chat
        function addUser(userId, username) {
            chatState.users[userId] = username;
            
            // Assign a color if needed
            if (!chatState.colors[userId]) {
                const colorIndex = chatState.nextColor % chatState.colorPalette.length;
                chatState.colors[userId] = chatState.colorPalette[colorIndex];
                chatState.nextColor++;
            }
            
            // Update the UI
            updateOnlineUsers();
        }
        
        // Update the online users display
        function updateOnlineUsers() {
            onlineUsers.innerHTML = '';
            
            Object.entries(chatState.users).forEach(([userId, username]) => {
                const userElement = document.createElement('div');
                userElement.classList.add('flex', 'items-center', 'mr-2', 'bg-gray-100', 'dark:bg-gray-700', 'px-2', 'py-1', 'rounded-full', 'text-xs');
                
                const indicator = document.createElement('span');
                indicator.classList.add('user-indicator');
                indicator.style.backgroundColor = chatState.colors[userId] || '#ccc';
                
                userElement.appendChild(indicator);
                userElement.appendChild(document.createTextNode(username));
                
                onlineUsers.appendChild(userElement);
            });
        }
        
        // Validate username
        function validateUsername(username) {
            return username && username.trim().length >= 3 && username.trim().length <= 20;
        }
        
        // Validate room ID
        function validateRoom(room) {
            const trimmed = room.trim();
            // Check length
            if (trimmed.length < 3 || trimmed.length > 20) return false;
            // Check if it contains only alphanumeric, spaces, and common punctuation
            return /^[a-zA-Z0-9 \-_.']+$/.test(trimmed);
        }
        
        // Join the chat
        function joinChat() {
            const username = usernameInput.value.trim();
            const room = roomInput.value.trim();
            let hasError = false;
            
            if (!validateUsername(username)) {
                usernameError.classList.remove('hidden');
                hasError = true;
            } else {
                usernameError.classList.add('hidden');
            }
            
            if (!validateRoom(room)) {
                roomError.classList.remove('hidden');
                hasError = true;
            } else {
                roomError.classList.add('hidden');
            }
            
            if (hasError) return;
            
            // Valid inputs
            chatState.username = username;
            chatState.roomId = room;
            
            // Initialize PeerJS
            initPeer();
        }
        
        // Send a chat message
        function sendMessage() {
            const content = messageInput.value.trim();
            
            if (!content || !chatState.isLoggedIn) return;
            
            const message = {
                type: 'chat',
                userId: chatState.userId,
                username: chatState.username,
                content: content,
                roomId: chatState.roomId,
                timestamp: new Date().toISOString()
            };
            
            // Add message to our own chat
            addMessage({
                sender: chatState.username,
                content: content,
                timestamp: message.timestamp,
                userId: chatState.userId,
                isSystem: false
            });
            
            // Send to peers
            if (chatState.isHost) {
                broadcastToPeers(message);
            } else if (chatState.hostConnection && chatState.hostConnection.open) {
                try {
                    chatState.hostConnection.send(message);
                } catch (err) {
                    console.error('Error sending message to host:', err);
                    addMessage({
                        sender: 'System',
                        content: 'Failed to send message. Connection may be lost.',
                        timestamp: new Date().toISOString(),
                        isSystem: true
                    });
                }
            } else {
                // Connection to host is lost
                addMessage({
                    sender: 'System',
                    content: 'Message could not be sent: No connection to host.',
                    timestamp: new Date().toISOString(),
                    isSystem: true
                });
                
                // Try to reconnect or become host
                if (!chatState.isHost && !chatState.connectedToHost) {
                    becomeHost();
                }
            }
            
            // Clear input
            messageInput.value = '';
            messageInput.focus();
        }
        
        // Format timestamp
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }
        
        // Add a message to the chat
        function addMessage(message, storeMessage = true) {
            if (storeMessage) {
                chatState.messages.push(message);
            }
            
            chatState.isLoggedIn = true;
            
            const messageEl = document.createElement('div');
            messageEl.classList.add('message', 'mb-3');
            
            if (message.isSystem) {
                messageEl.innerHTML = `
                    <div class="p-2 rounded bg-gray-100 dark:bg-gray-700 inline-block">
                        <span class="font-medium text-gray-500 dark:text-gray-400">${message.content}</span>
                        <span class="timestamp text-gray-400 dark:text-gray-500">${formatTime(message.timestamp)}</span>
                    </div>
                `;
            } else {
                const isCurrentUser = message.userId === chatState.userId;
                const userColor = chatState.colors[message.userId] || '#ccc';
                
                messageEl.innerHTML = `
                    <div class="flex ${isCurrentUser ? 'justify-end' : 'justify-start'}">
                        <div class="p-2 rounded-lg ${isCurrentUser ? 'bg-[var(--primary-color)] text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-900 dark:text-white'} max-w-[80%]">
                            ${!isCurrentUser ? `
                                <div class="flex items-center mb-1">
                                    <span class="user-indicator" style="background-color: ${userColor}"></span>
                                    <span class="font-bold">${message.sender}</span>
                                </div>` : ''}
                            <span>${message.content}</span>
                            <span class="timestamp ${isCurrentUser ? 'text-gray-200' : 'text-gray-500 dark:text-gray-400'}">${formatTime(message.timestamp)}</span>
                        </div>
                    </div>
                `;
            }
            
            messagesContainer.appendChild(messageEl);
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // Change username/room (go back to login screen)
        function changeUsername() {
            // Add a leaving message
            const leaveMessage = {
                type: 'leave',
                userId: chatState.userId,
                username: chatState.username,
                roomId: chatState.roomId,
                timestamp: new Date().toISOString()
            };
            
            // Send leave message to peers
            if (chatState.isHost) {
                broadcastToPeers(leaveMessage);
                
                // Remove ourselves from the user list
                delete chatState.users[chatState.userId];
                updateOnlineUsers();
            } else if (chatState.hostConnection && chatState.hostConnection.open) {
                try {
                    chatState.hostConnection.send(leaveMessage);
                } catch (e) {
                    // Ignore errors during disconnection
                    console.log('Error sending leave message:', e);
                }
            }
            
            // Close connections
            chatState.connections.forEach(conn => {
                if (conn.open) {
                    conn.close();
                }
            });
            
            if (chatState.hostConnection && chatState.hostConnection.open) {
                chatState.hostConnection.close();
            }
            
            if (chatState.peer) {
                chatState.peer.destroy();
            }
            
            // Reset state and show username screen
            chatState.isLoggedIn = false;
            chatState.isHost = false;
            chatState.connectedToHost = false;
            chatState.connections = [];
            chatState.hostConnection = null;
            chatState.messages = [];
            chatState.users = {};
            chatState.colors = {};
            chatState.nextColor = 0;
            chatState.reconnectAttempts = 0;
            
            // Update UI
            usernameInput.value = chatState.username;
            roomInput.value = chatState.roomId;
            messagesContainer.innerHTML = '<div class="flex justify-center p-4"><p class="text-gray-500 dark:text-gray-400 text-sm">Welcome to the chat! Messages appear here.</p></div>';
            onlineUsers.innerHTML = '';
            
            chatScreen.classList.add('hidden');
            usernameScreen.classList.remove('hidden');
            connectionStatus.textContent = '';
        }
        
        // Retry connection
        function retryConnection() {
            // Reset connection attempts counter
            chatState.reconnectAttempts = 0;
            
            // Hide error and retry button
            connectionError.classList.add('hidden');
            retryBtn.classList.add('hidden');
            
            // Try connecting again
            initPeer();
        }
        
        // Event listeners
        joinBtn.addEventListener('click', joinChat);
        
        usernameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                // If room is already filled, join chat
                if (validateRoom(roomInput.value)) {
                    joinChat();
                } else {
                    // Otherwise, focus the room field
                    roomInput.focus();
                }
            }
        });
        
        roomInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') joinChat();
        });
        
        sendBtn.addEventListener('click', sendMessage);
        
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
        
        changeUsernameBtn.addEventListener('click', changeUsername);
        
        retryBtn.addEventListener('click', retryConnection);
        
        // Update current user display
        function updateCurrentUser() {
            currentUserSpan.textContent = chatState.username;
        }
        
        // Focus username input when page loads
        usernameInput.focus();
        
        // Add a window beforeunload event to handle closing the tab
        window.addEventListener('beforeunload', () => {
            // If logged in, try to send a leave message
            if (chatState.isLoggedIn) {
                const leaveMessage = {
                    type: 'leave',
                    userId: chatState.userId,
                    username: chatState.username,
                    roomId: chatState.roomId,
                    timestamp: new Date().toISOString()
                };
                
                // Send leave message to peers
                if (chatState.isHost) {
                    broadcastToPeers(leaveMessage);
                } else if (chatState.hostConnection && chatState.hostConnection.open) {
                    try {
                        chatState.hostConnection.send(leaveMessage);
                    } catch (e) {
                        // Ignore errors during page unload
                    }
                }
                
                // Close connections
                if (chatState.peer) {
                    chatState.peer.destroy();
                }
            }
        });
    </script>
</body>
</html>
